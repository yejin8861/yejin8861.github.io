---
title: "[파이썬 S/W 문제해결 이론] 탐욕(그리디) 알고리즘"
excerpt: "SW Expert Academy Programming Advanced - 03 탐욕 알고리즘"

categories:
  - Algorithm
tags:
  - python
  - SWEA
  - Algorithm
  - greedy
---
  
  

## 탐욕(그리디) 알고리즘이란?
- 최적화 문제를 해결하는 알고리즘
: 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 최적화 문제: 최적(최대값 이나 최소값 같은) 값을 구하는 문제
: 해당 문제에 여러 해가 있을 수 있음
- 머리 속에 떠오르는 생각을 검증 없이 바로 구현할 경우 Greedy 접근이 됨
- 여러 경우 중 하나 선택 -> 선택 시 마다 **최적**이라고 생각되는 것을 선택 -> 최종적인 해답에 도달  
- 선택들을 계속 수집해 최종적 해답을 만들었다고 하여 최적이라는 보장은 없음  

  
  
## 탐욕 알고리즘의 수행 과정
1. 해 선택
- 현재 상태에서 부분 문제의 최적해를 구한 뒤, **부분 해 집합(Solution Set)**에 추가
- 하나의 선택이 이루어지면 새로운 부분 문제 발생
2. 실행 가능성 검사 실시
- 새로운 부분 해 집합의 **실행가능 여부 확인**
- 문제의 **제약 조건 위반을 검사**
3. 해 검사
- 새로운 부분 해 집합이 문제의 해가 되는지 확인
- 전체 문제의 해가 완성되지 않았다면 **1의 해 선택부터 다시 시작**
  
  
## 예시 문제
### 동전 거스름돈 문제
손님이 지불한 금액에서 거스름돈으로 주는 **지폐와 동전의 개수를 최소한**으로 줄이는 문제 
1. 해 선택
- 단위가 큰 동전으로 거스름돈을 하면 동전의 개수가 줄어드므로 **현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가**
2. 실행 가능성 검사
- 거스름돈이 **액수를 초과하는지 확인**
- 초과할 경우 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가 현재보다 한 단계 작은 단위의 동전 추가
3. 해 검사
- 거스름돈 문제의 해 = 손님에게 내드려야 하는 거스름돈의 액수
- 거스름돈을 확인해 액수에 모자라면 다시 1로 돌아가 거스름돈에 추가할 동전 선택
  
하지만 거스름돈이 800원일 경우 동전의 종류가 10,50,100,400,500원이 있다면 탐욕 알고리즘을 풀 수 없다. 왜냐하면 탐욕 알고리즘으로는 500원이 부분 최적해가 되어 500+100+100+100을 고르기 때문이다. 따라서 이러한 경우엔 완전 검색으로 모든 경우의 수를 파악하여 800원이 되기 까지의 간선의 수가 최소인 경우를 골라야 한다.  
  
### 활동 선택 문제
사용 가능한 회의실이 하나만 존재할 때 가능한 많은 회의가 열리기 위해 배정하는 문제  
1. 종료 시간이 빠른 순서로 활동들 정렬
2. 첫 번째 활동을 선택하고 해집합에 포함
3. 선택한 활동의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거  
이는 종료 시간이 가장 빠른 활동을 선택하는 것은 항상 안전하다는 증명이 되기 때문에 가능
  
  
### Baby-Gin 문제
Baby Gin을 가지기 위해서는 모든 6장의 카드가 run이거나 tripletes이여야 한다.  
예를 들어, 444456 이라는 숫자가 있을 때 444(triplets), 456(run)이기 때문에 Baby Gin이다.  
이 문제는 탐욕 기법을 통해 풀 수 있다. 0~9까지의 인덱스를 가지는 counts 배열에 각 숫자의 개수만큼 값을 저장한다. 그 중 tripletes나 run을 조사 후 tripletes나 run에 해당하는 숫자의 개수를 감소시킨 뒤 남은 숫자로 한번 더 run과 tripletes에 해당하는지 조사한다.  
![Baby-Gin](/home/yejin/yejin8861.github.io/assets/images/greedy_Baby_Gin.JPG)  
  

## 탐욕 기법과 동적 계획법의 비교

탐욕 기법 | 동적 계획법
--------- | ----------
매 단계에서, 가장 좋아 보이는 것을 빠르게 선택 -> 지역 최적 선택 | 매 단계의 선택은 해결한 하위 문제의 해를 기반
하위 문제를 풀기 전 (탐욕적)선택이 먼저 이루어짐 | 하위 문제가 우선 해결
Top-down 방식 | Bottom-up 방식
일반적으로 빠르고 간결하다. | 좀 더 느리고 복잡하다.

## 대표적인 탐욕 기법의 알고리즘들
Prim, Kruskal, Dijkstra, Huffman coding 
