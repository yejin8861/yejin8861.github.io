---
title: "C++ STL 개요"
excerpt: "C++에서 자주 사용되는 라이브러리인 STL에 대한 소개."

categories:
  - C++
tags:
  - C++
  - STL
---

# STL 소개
## 일반화 프로그래밍이란?
한 번 만든 자료 구조나 알고리즘을 수정없이 재사용할 수 있다면 좋을 것이고 이 중 하나가 바로 객체 지향 프로그래밍 방법(OOP)이다. OOP는 재사용성에 있어서 탁월한 성능을 보여주며 그 성능이 이미 입증되었다. OOP이후의 또다른 시도인 STL은 일반화 프로그래밍 기법이라는 좀 더 발전된 개념의 재사용성을 제공한다. 일반화(Generic)는 객체 지향의 다음 세대라고 일컬어지는데 두 가지 측면에서 일반성을 제공한다.

- 임의 타입에 사용할 수 있는 자료 구조를 만들 수 있다.  
: 정수, 실수 등의 기본 타입은 물론이고 사용자 정의형 타입과 그 유도형까지도 관리할 수 있는 자료 구조를 정의할 수 있다.  
- 자료 구조의 형태나 내부 구조에 상관없이 임의의 데이터 집합에 적용할 수 있는 일반화된 알고리즘을 제공한다.  
: 자료 구조에 상관없이 사용 방법이 동일하므로 어떤 형태의 데이터에 대해서도 적용할 수 있다. 논리적으로 비슷한 작업은 같은 방법으로 수행할 수 있으며 이를 위해 반복자라는 일반화된 포인터를 사용한다.
  

## STL(Standard Template Library)이란?
일반화의 개념에 의해 자주 사용되는 자료 구조와 알고리즘을 제공하는 라이브러리.  
개발자는 자료 구조를 일일이 구현할 필요없이 STL이 제공하는 자료 구조를 선택해서 사용할 수 있으며 하나의 알고리즘을 임의의 자료 구조에 대해 일관되게 사용할 수 있다. 최소한의 의사표현만으로 모든 처리가 자동으로 수행된다.  

## 1. STL의 특징
### 1-1. STL의 장점
- 일반화를 지원한다.  
: 하나의 단일 알고리즘으로 복수 개의 컨테이너에 동일한 작업을 똑같은 방법으로 수행할 수 있다.
- 컴파일 타임 메커니즘을 사용하기 때문에 실행시의 효율 저하가 거의 없다.  
: STL을 쓰지 않았을 때의 코드에 비해 현격한 속도 차이가 없으며 오히려 더 빠른 경우도 있다.(그러나 고수준 라이브러리 특성상 제대로 쓸 때만 이상적인 효율이 발휘된다.)
- 객체 지향적이지 않다.  
: 객체를 사용하기는 하지만 STL 자체가 객체를 반드시 요구하는 것은 아니다.
- 표준이므로 이식성이 당연히 확보된다.  
: STL로 작성한 코드는 표준을 준수하는 어떠한 컴파일러로도 문제없이 컴파일할 수 있다.
- 확장 가능하다.  
: 소스가 공개되어 있으므로 STL라이브러리를 분석하여 원하는 컨테이너와 알고리즘을 직접 작성하여 사용할 수 있다.  

### 1-2. STL의 단점
- 템플릿에 기반하기 때문에 타입마다 함수와 클래스가 매번 구체화되어 코드가 비대해진다.  
: 완전히 똑같은 컨테이너라도 타입이 바뀌면 두 벌의 거대한 코드 집합이 따로 생성된다. 극단적으로 표현하자면 약간의 속도 향상을 위해 크기는 아예 완전히 포기한 셈.
- STL로 작성한 코드는 가독성이 심하게 떨어진다.  
: 소스가 난해하기 때문에 팀 프로젝트에 불리하며 디버깅도 어렵고 유지 보수 비용이 증가한다.

  
## 2. STL의 구조
![STL](http://soen.kr/lecture/ccpp/cpp4/37-2-1.files/image002.gif "SLT 구성요소")  

STL은 컨테이너, 알고리즘, 반복자가 가장 중요한 세 요소이며 STL 학습의 대부분이 이 세 요소에 치중된다. 네 번째 요소인 함수 객체는 알고리즘의 활용성을 높이는 역할을 하며 다섯 번째 요소인 어댑터는 다른 요소들을 약간만 수정하여 형태를 변형한다. 마지막 구성 요소인 할당기는 컨테이너의 메모리를 관리하는 객체인데 디폴트가 잘 작성되어 있으므로 거의 신경쓸 필요가 없다.

### 2-1. 컨테이너란?
컨테이너(Container)를 뜻 그대로 직역하면 통, 그릇이다. STL의 컨테이너는 타입이 같은, 즉 동질적인 객체의 집합을 저장하고 관리하는 역할을 하는데 C와 C++에서 배웠던 배열, 연결 리스트, 스택 따위가 컨테이너의 좋은 예이다.
#### 컨테이너의 종류
- 시퀀스 컨테이너(Sequence Container) : 자료의 선형적인 집합, 자료를 저장하는 기본 임무에 충실한 가장 일반적인 컨테이너. 사용자는 시퀀스의 임의 위치에 원하는 요소를 마음대로 삽입, 삭제 가능 (**벡터, 리스트, 데크**)
- 연관 컨테이너(Associative Container) : 자료를 무조건 저장하기만 하는 것이 아닌 일정한 규칙에 따라 자료를 조직화하여 관리하는 컨테이너. 정렬이나 해시 등의 방법을 통해 삽입되는 자료를 항상 일정한 기준에 마즌ㄴ 위치에 저장해 놓으므로 검색 속도가 빠름.(**셋, 맵**)
- 어댑터 컨테이너(Adapter Container) : 시퀀스 컨테이너를 변형하여 자료를 미리 정해진 일정한 방식에 따라 관리. (**스택, 큐, 우선순위 큐**)  
  
세 부류의 컨테이너는 삽입, 삭제 규칙에 있어서 차이가 있다. 시퀀스는 삽입, 삭제에 별 제약이 없지만 연관 컨테이너는 신속한 검색을 위해 찾기 좋은 위치에 자동 삽입되며 어댑터는 FIFO, LIFO등의 미리 정한 규칙의 통제를 따른다.  
수시로 변하는 자료 -> 검색은 느리지만 삽입, 삭제가 빠른 리스트가 적합.  
대용량의 참조용 자료 -> 삽입, 삭제가 느리지만 읽기 속도가 빠른 벡터가 적합.  
  
  
### 2-2. 벡터란?
쉽게 말해서 동적 배열. 요소의 개수에 맞게 자동으로 메모리를 재할당하여 크기를 신축적으로 늘릴 수 있는 배열.  
![vector](http://soen.kr/lecture/ccpp/cpp4/37-2-1.files/image004.gif "vector")  
#### vector
```cpp
#include <iostream>
#include <vector>
using namespace std;

void main()
{
     int num;
     int i;

     printf("배열 크기를 입력하시오 : ");
     scanf("%d",&num);
     vector<int> vi(num);

     for (i=0;i<num;i++) {
          vi[i]=i*2;
     }
     for (i=0;i<num;i++) {
          printf("vi[%d]=%d\n",i,vi[i]);
     }
     printf("벡터의 크기는 %d입니다.\n",vi.size());
}
```
정적 배열의 크기는 반드시 상수로만 지정할 수 있는데 비해 벡터는 실행중에 생성되므로 변수로도 크기를 지정할 수 있다. 벡터는 임의 접근이 가능하므로 벡터내의 아무 요소나 읽고 쓸 수 있다.

##### 실행 결과
```
배열 크기를 입력하시오 : 4
vi[0]=0
vi[1]=2
vi[2]=4
vi[3]=6
벡터의 크기는 4입니다.
```  
  
#### pushback
```cpp
#include <iostream>
#include <vector>
using namespace std;

void main()
{
     int i;
     vector<int> vi;

     for (i=0;i<10;i++) {
          vi.push_back(i*2);
     }
     for (i=0;i<10;i++) {
          printf("vi[%d]=%d\n",i,vi[i]);
     }
     printf("벡터의 크기는 %d입니다.\n",vi.size());
}
```
**push_back**은 제일 뒤에 새로운 요소 하나를 추가(append)하며 이 과정에서 벡터의 메모리가 부족하다면 재할당된다.  
벡터는 요소들을 인접한 메모리 위치에 연속적으로 저장한다. 그래서 단순한 첨자 연산만으로도 원하는 요소를 빠르게 읽고 쓸 수 있으며 임의의 요소로 이동하는 동작도 상수 시간에 수행할 수 있다. 읽기 속도가 빠르므로 정렬이나 이분 검색 등의 알고리즘에 대단히 효율적이다. 그러나 임의 접근이 가능하기 위해서는 요소 인접 조건을 항상 만족해야 하므로 중간에서 삽입 삭제할 때는 메모리를 밀고 당기는 처리를 해야 하며 따라서 삽입, 삭제 속도는 느리다.  
  
  
### 2-3. 리스트란?
리스트는 이중 연결 리스트로 구현된 컨테이너이다. 리스트의 요소들은 노드라는 구조체로 관리되며 노드끼리는 링크로 서로 연결되어 있어 요소의 논리적인 순서를 기어거한다. 노드는 인접한 메모리에 배치되지 않아도 상관없으며 삽입, 삭제할 때도 앞 뒤 노드의 링크만 조작하므로 삽입, 삭제 속도가 대단히 빠르다. 반면 리스트의 한 요소를 찾으려면 첫 노드부터 순서대로 링크를 따라 이동해야 하므로 읽기 속도는 무척 느리다.  

#### list
```cpp
#include <iostream>
#include <list>
using namespace std;

void main()
{
     list<int> li;
     int i;

     for (i=0;i<5;i++) {
          li.push_back(i*2);
     }
     list<int>::iterator it;
     for (it=li.begin(),i=0;it!=li.end();it++,i++) {
          printf("%d번째=%d\n",i,*it);
     }
}
``` 

```
0번째=0
1번째=2
2번째=4
3번째=6
4번째=8
```
리스트의 노드들은 메모리의 곳곳에 흩어져 존재하며 임의 접근이 불가능하므로 모든 요소를 순회하려면 링크를 따라 순서대로 이동하는 수밖에 없다. 이때는 흔히 노드를 가리키는 포인터가 사용되는데 STL에서는 포인터 대신 반복자라는 특별한 객체를 사용한다.  
예제 코드의 it가 바로 정수형 리스트이 반복자이다. 리스트의 begin 멤버 함수는 첫 번째 요소(헤더의 위치), end는 마지막 요소(테일의 위치)를 구한다. 반복자를 헤더에서 테일 직전까지 순회하면서 반복자가 가리키는 요소인 *it를 읽어 출력하면 리스트의 모든 요소를 순회하면서 그 값을 출력할 수 있다.  
  
    

### 2-4. map이란?
맵은 두 개씩 짝을 이루는 데이터를 저장하는 컨테이너이다. 연관 컨테이너의 일종인 맵은 시퀀스와는 달리 아무렇게나 요소를 저장하지 않고 정렬된 위치에 삽입한다. 항상 정렬된 상태로 관리되므로 이분 검색 기법을 사용할 수 있으며 대량의 데이터를 신속하게 검색해야 할 때 맵이 주로 사용된다.  
다음 예제는 편의점의 상품과 가격 목록을 맵에 저장해 두고 상품명으로 가격을 검색한다. 상품의 이름은 문자열이고 가격은 정수이며 두 개가 한 쌍이 되어 상품 하나의 정보를 표현하므로 이 쌍을 저장하기 위한 컨테이너로는 맵이 가장 적당하다.  
```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;
 
struct SProduct
{
     string Name;
     int Price;
} arPro[]={
     {"맛동산",500},{"박카스",400},{"네스카페",250},{"신라면",450},
     {"88라이트",1900},{"불티나",300},{"스타킹",700},{"김치",2000},
     {"신문",500},{"비타500",500},{"비타1000",1000},{"왕꿈틀이",900},
     {"뽀빠이",200},{"위스퍼",800},{"콘텍600",600},{"페리오치약",2200},
     {"모나미볼펜",90},{"까페라떼",990},{"밧데리",1000},{"쵸코파이",250},
};
 
void main()
{
     map<string,int> mPro;
     map<string,int>::iterator it;
     int i;
     string Name;

     for (i=0;i<sizeof(arPro)/sizeof(arPro[0]);i++) {
          mPro[arPro[i].Name]=arPro[i].Price;
     }

     for (;;) {
          cout << "상품명을 입력하시오(끝낼때는 '끝'입력) : ";
          cin >> Name;
          if (Name=="끝") break;
          it=mPro.find(Name);
          if (it == mPro.end()) {
              cout << "그런 제품은 없습니다." << endl;
          } else {
              cout << Name << "의 가격은 " << it->second << "입니다." << endl;
          }
     }
}
```
##### 실행 결과
```
상품명을 입력하시오(끝낼때는 '끝'입력) : 뽀빠이
뽀빠이의 가격은 200입니다.
상품명을 입력하시오(끝낼때는 '끝'입력) : 밧데리
밧데리의 가격은 1000입니다.
상품명을 입력하시오(끝낼때는 '끝'입력) : 끝
```
상품 이름을 입력하면 가격이 바로 조사된다. 맵은 항상 정렬된 상태로 자료를 관리하므로 검색 속도가 빠른 것이 큰 장점이다.
